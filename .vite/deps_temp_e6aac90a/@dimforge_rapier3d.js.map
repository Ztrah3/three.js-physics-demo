{
  "version": 3,
  "sources": ["../../node_modules/@dimforge/rapier3d/src/exports.ts", "../../node_modules/@dimforge/rapier3d/rapier_wasm3d.js", "../../node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js", "../../node_modules/@dimforge/rapier3d/src/math.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/rigid_body.ts", "../../node_modules/@dimforge/rapier3d/src/coarena.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/rigid_body_set.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/integration_parameters.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/impulse_joint.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/impulse_joint_set.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/multibody_joint.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/multibody_joint_set.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/coefficient_combine_rule.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/ccd_solver.ts", "../../node_modules/@dimforge/rapier3d/src/dynamics/island_manager.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/broad_phase.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/narrow_phase.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/contact.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/feature.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/point.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/ray.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/toi.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/shape.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/collider.ts", "../../node_modules/@dimforge/rapier3d/src/geometry/collider_set.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/physics_pipeline.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/query_pipeline.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/serialization_pipeline.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/debug_render_pipeline.ts", "../../node_modules/@dimforge/rapier3d/src/control/character_controller.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/world.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/event_queue.ts", "../../node_modules/@dimforge/rapier3d/src/pipeline/physics_hooks.ts", "../../node_modules/@dimforge/rapier3d/src/rapier.ts"],
  "sourcesContent": ["import {version as vers} from \"./raw\";\n\nexport function version(): string {\n    return vers();\n}\n\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n", "import * as wasm from \"./rapier_wasm3d_bg.wasm\";\nexport * from \"./rapier_wasm3d_bg.js\";", "import * as wasm from './rapier_wasm3d_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = new Float32Array();\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = new Uint32Array();\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Spherical:3,\"3\":\"Spherical\",Generic:4,\"4\":\"Generic\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",Z:2,\"2\":\"Z\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\",HalfSpace:17,\"17\":\"HalfSpace\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        return RawBroadPhase.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCCDSolver.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        return RawCCDSolver.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCharacterCollision.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        return RawCharacterCollision.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationApplied() {\n        const ret = wasm.rawcharactercollision_translationApplied(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationRemaining() {\n        const ret = wasm.rawcharactercollision_translationRemaining(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.ptr, handle, newHalfExtents.ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.ptr, handle, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.ptr, handle, colliderVel.ptr, shape2.ptr, shape2Pos.ptr, shape2Rot.ptr, shape2Vel.ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.ptr, handle, collider1Vel.ptr, collider2handle, collider2Vel.ptr, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.ptr, handle, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.ptr, handle, shape.ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.ptr, handle, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        return RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.ptr, enabled, shape.ptr, translation.ptr, rotation.ptr, massPropsMode, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.ptr, handle, islands.ptr, bodies.ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactPair.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDebugRenderPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        return RawDebugRenderPipeline.__wrap(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr, narrow_phase.ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawEventQueue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        return RawEventQueue.__wrap(ret);\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Create a new joint descriptor that builds spehrical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.ptr, anchor2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.ptr, anchor2.ptr, axis.ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.ptr, axes1.ptr, anchor2.ptr, axes2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.ptr, anchor2.ptr, axis.ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.ptr, handle, newPos.ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.ptr, handle, newPos.ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        return RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.ptr, params.ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        return RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawintegrationparameters_allowedLinearError(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawintegrationparameters_predictionDistance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityFrictionIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxStabilizationIterations() {\n        const ret = wasm.rawintegrationparameters_maxStabilizationIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityFrictionIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxStabilizationIterations(value) {\n        wasm.rawintegrationparameters_set_maxStabilizationIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, value);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        return RawIslandManager.__wrap(ret);\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawKinematicCharacterController.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        return RawKinematicCharacterController.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawkinematiccharactercontroller_up(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.ptr, vector.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawkinematiccharactercontroller_offset(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.ptr, dt, bodies.ptr, colliders.ptr, queries.ptr, collider_handle, desired_translation.ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.ptr, i, collision.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        return RawMultibodyJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.ptr, params.ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        return RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contacts_with(handle1, f) {\n        wasm.rawnarrowphase_contacts_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersections_with(handle1, f) {\n        wasm.rawnarrowphase_intersections_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPhysicsPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        return RawPhysicsPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr, eventQueue.ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawQueryPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        return RawQueryPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.ptr, bodies.ptr, colliders.ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.ptr, bodies.ptr, colliders.ptr, point.ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.ptr, bodies.ptr, colliders.ptr, point.ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.ptr, bodies.ptr, colliders.ptr, point.ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shapeVel.ptr, shape.ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, aabbCenter.ptr, aabbHalfExtents.ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawraycolliderintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawraycolliderintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawrayintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawrayintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.ptr, handle, linvel.ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.ptr, handle, angvel.ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.ptr, handle, colliders.ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.ptr, handle, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The principal vectors of the local angular inertia tensor of the rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbPrincipalInertiaLocalFrame(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {number} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.ptr, handle, force.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.ptr, handle, impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.ptr, handle, torque.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, handle, torque_impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.ptr, handle, force.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, handle, impulse.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        return RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {number} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.ptr, enabled, translation.ptr, rotation.ptr, gravityScale, mass, massOnly, centerOfMass.ptr, linvel.ptr, angvel.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.ptr, handle, islands.ptr, colliders.ptr, joints.ptr, articulations.ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawrigidbodyset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.ptr, colliders.ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRotation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawrotation_w(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSdpMatrix3 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSdpMatrix3.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawsdpmatrix3_free(ptr);\n    }\n    /**\n    * Row major list of the upper-triangular part of the symmetric matrix.\n    * @returns {Float32Array}\n    */\n    elements() {\n        const ret = wasm.rawsdpmatrix3_elements(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSerializationPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        return RawSerializationPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShape.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.ptr, p2.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.ptr, p2.ptr, p3.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.ptr, p2.ptr, p3.ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shapeVel1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, shapeVel2.ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecollidertoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawshapecontact_distance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapetoi_witness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapetoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapetoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawVector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawvector_set_y(this.ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_168da88779e35f61() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_3999bee59e9f7719() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_e1f72c051cdab859() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_10dfe70e95d2a480(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_3f3d764d4747d564(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_d9aa266703cb98be(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8c3f0052272a457a(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_83db9690f9353e79(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_9e1ae1900cb0fbd5(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_0e0314cf6675c1b9(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_9a2deed95d22668d(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_a7168e4a1e8f5e12(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n", "import {RawVector, RawRotation} from \"./raw\";\n// #if DIM3\nimport {RawSdpMatrix3} from \"./raw\";\n// #endif\n\n\n// #if DIM3\nexport interface Vector {\n    x: number;\n    y: number;\n    z: number;\n}\n\n/**\n * A 3D vector.\n */\nexport class Vector3 implements Vector {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number, z: number): Vector {\n        return new Vector3(x, y, z);\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y, v.z);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw) return null;\n\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n\n    public static copy(out: Vector, input: Vector) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n\nexport interface Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\n/**\n * A quaternion.\n */\nexport class Quaternion implements Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n\n    constructor(x: number, y: number, z: number, w: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\n\nexport class RotationOps {\n    public static identity(): Rotation {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw) return null;\n\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(rot: Rotation): RawRotation {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n\n    public static copy(out: Rotation, input: Rotation) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n\n/**\n * A 3D symmetric-positive-definite matrix.\n */\nexport class SdpMatrix3 {\n    /**\n     * Row major list of the upper-triangular part of the symmetric matrix.\n     */\n    elements: Float32Array;\n\n    /**\n     * Matrix element at row 1, column 1.\n     */\n    public get m11(): number {\n        return this.elements[0];\n    }\n\n    /**\n     * Matrix element at row 1, column 2.\n     */\n    public get m12(): number {\n        return this.elements[1];\n    }\n\n    /**\n     * Matrix element at row 2, column 1.\n     */\n    public get m21(): number {\n        return this.m12;\n    }\n\n    /**\n     * Matrix element at row 1, column 3.\n     */\n    public get m13(): number {\n        return this.elements[2];\n    }\n\n    /**\n     * Matrix element at row 3, column 1.\n     */\n    public get m31(): number {\n        return this.m13;\n    }\n\n    /**\n     * Matrix element at row 2, column 2.\n     */\n    public get m22(): number {\n        return this.elements[3];\n    }\n\n    /**\n     * Matrix element at row 2, column 3.\n     */\n    public get m23(): number {\n        return this.elements[4];\n    }\n\n    /**\n     * Matrix element at row 3, column 2.\n     */\n    public get m32(): number {\n        return this.m23;\n    }\n\n    /**\n     * Matrix element at row 3, column 3.\n     */\n    public get m33(): number {\n        return this.elements[5];\n    }\n\n    constructor(elements: Float32Array) {\n        this.elements = elements;\n    }\n}\n\nexport class SdpMatrix3Ops {\n    public static fromRaw(raw: RawSdpMatrix3): SdpMatrix3 {\n        const sdpMatrix3 = new SdpMatrix3(raw.elements());\n        raw.free();\n        return sdpMatrix3;\n    }\n}\n\n// #endif\n", "import {RawRigidBodySet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n// #if DIM3\nimport {SdpMatrix3, SdpMatrix3Ops} from \"../math\";\n// #endif\nimport {Collider, ColliderSet} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    Fixed,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    private colliderSet: ColliderSet;\n    readonly handle: RigidBodyHandle;\n\n    /**\n     * An arbitrary user-defined object associated with this rigid-body.\n     */\n    public userData?: unknown;\n\n    constructor(\n        rawSet: RawRigidBodySet,\n        colliderSet: ColliderSet,\n        handle: RigidBodyHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.colliderSet = colliderSet;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledTranslations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledRotations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity fo this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(rot: Rotation, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    // #endif\n\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    public setNextKinematicRotation(rot: Rotation) {\n        this.rawSet.rbSetNextKinematicRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    // #endif\n\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n\n    // #endif\n\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    public effectiveInvMass(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    public invMass(): number {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    public localCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    public worldCom(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n\n\n    // #if DIM3\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    public invPrincipalInertiaSqrt(): Vector {\n        return VectorOps.fromRaw(\n            this.rawSet.rbInvPrincipalInertiaSqrt(this.handle),\n        );\n    }\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    public principalInertia(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));\n    }\n    // #endif\n\n    // #if DIM3\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     */\n    public principalInertiaLocalFrame(): Rotation {\n        return RotationOps.fromRaw(\n            this.rawSet.rbPrincipalInertiaLocalFrame(this.handle),\n        );\n    }\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    public effectiveWorldInvInertiaSqrt(): SdpMatrix3 {\n        return SdpMatrix3Ops.fromRaw(\n            this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle),\n        );\n    }\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    public effectiveAngularInertia(): SdpMatrix3 {\n        return SdpMatrix3Ops.fromRaw(\n            this.rawSet.rbEffectiveAngularInertia(this.handle),\n        );\n    }\n    // #endif\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled(): boolean {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): Collider {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    public setEnabled(enabled: boolean) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this rigid-body enabled?\n     */\n    public isEnabled(): boolean {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    public setBodyType(type: RigidBodyType, wakeUp: boolean) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isFixed(): boolean {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    public recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(\n            this.handle,\n            this.colliderSet.raw,\n        );\n    }\n\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isn’t desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders’ contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMass(mass: number, wakeUp: boolean) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders’ contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n        wakeUp: boolean,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.rawSet.rbSetAdditionalMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            wakeUp,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetForces(wakeUp: boolean) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetTorques(wakeUp: boolean) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(impulse: Vector, wakeUp: boolean) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addTorque(torque: Vector, wakeUp: boolean) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: Vector, wakeUp: boolean) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n\n    // #endif\n\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(\n            this.handle,\n            rawImpulse,\n            rawPoint,\n            wakeUp,\n        );\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\n\nexport class RigidBodyDesc {\n    enabled: boolean;\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    massOnly: boolean;\n    centerOfMass: Vector;\n    translationsEnabledX: boolean;\n    translationsEnabledY: boolean;\n    linvel: Vector;\n    // #if DIM3\n    angvel: Vector;\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    translationsEnabledZ: boolean;\n    rotationsEnabledX: boolean;\n    rotationsEnabledY: boolean;\n    rotationsEnabledZ: boolean;\n    // #endif\n    linearDamping: number;\n    angularDamping: number;\n    status: RigidBodyType;\n    canSleep: boolean;\n    sleeping: boolean;\n    ccdEnabled: boolean;\n    dominanceGroup: number;\n    userData?: unknown;\n\n    constructor(status: RigidBodyType) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static dynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static kinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static kinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    public static fixed(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled − If set to `false` the rigid-body will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): RigidBodyDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    public setTranslation(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    public setLinvel(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y, z: z};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: Vector): RigidBodyDesc {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     * @param centerOfMass − The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame − The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): RigidBodyDesc {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        this.massOnly = false;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    public enabledTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledTranslations(\n            translationsEnabledX,\n            translationsEnabledY,\n            translationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        return this.enabledTranslations(false, false, false);\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    public enabledRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledRotations(\n            rotationsEnabledX,\n            rotationsEnabledY,\n            rotationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        return this.restrictRotations(false, false, false);\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping: boolean): RigidBodyDesc {\n        this.sleeping = sleeping;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    public setUserData(data?: unknown): RigidBodyDesc {\n        this.userData = data;\n        return this;\n    }\n}\n", "export class Coarena<T> {\n    fconv: Float64Array;\n    uconv: Uint32Array;\n    data: Array<T>;\n    size: number;\n\n    public constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array<T>();\n        this.size = 0;\n    }\n\n    public set(handle: number, data: T) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n\n        if (this.data[i] == null) this.size += 1;\n        this.data[i] = data;\n    }\n\n    public len(): number {\n        return this.size;\n    }\n\n    public delete(handle: number) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null) this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n\n    public clear() {\n        this.data = new Array<T>();\n    }\n\n    public get(handle: number): T | null {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        } else {\n            return null;\n        }\n    }\n\n    public forEach(f: (elt: T) => void) {\n        for (const elt of this.data) {\n            if (elt != null) f(elt);\n        }\n    }\n\n    public getAll(): Array<T> {\n        return this.data.filter((elt) => elt != null);\n    }\n\n    private index(handle: number): number {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we don’t really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n", "import {RawRigidBodySet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {VectorOps, RotationOps} from \"../math\";\nimport {RigidBody, RigidBodyDesc, RigidBodyHandle} from \"./rigid_body\";\nimport {ColliderSet} from \"../geometry\";\nimport {ImpulseJointSet} from \"./impulse_joint_set\";\nimport {MultibodyJointSet} from \"./multibody_joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n    private map: Coarena<RigidBody>;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena<RigidBody>();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle: RigidBodyHandle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(\n        colliderSet: ColliderSet,\n        desc: RigidBodyDesc,\n    ): RigidBody {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createRigidBody(\n            desc.enabled,\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.massOnly,\n            rawCom,\n            rawLv,\n            // #if DIM3\n            rawAv,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            desc.translationsEnabledX,\n            desc.translationsEnabledY,\n            desc.translationsEnabledZ,\n            desc.rotationsEnabledX,\n            desc.rotationsEnabledY,\n            desc.rotationsEnabledZ,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status,\n            desc.canSleep,\n            desc.sleeping,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n\n        this.map.set(handle, body);\n\n        return body;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(\n        handle: RigidBodyHandle,\n        islands: IslandManager,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) =>\n            impulseJoints.unmap(handle),\n        );\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(\n            handle,\n            (handle) => multibodyJoints.unmap(handle),\n        );\n\n        // Remove the rigid-body.\n        this.raw.remove(\n            handle,\n            islands.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (body: RigidBody) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(\n        islands: IslandManager,\n        f: (body: RigidBody) => void,\n    ) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    public getAll(): RigidBody[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters;\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp(): number {\n        return this.raw.erp;\n    }\n\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError(): number {\n        return this.raw.allowedLinearError;\n    }\n\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance(): number {\n        return this.raw.predictionDistance;\n    }\n\n    /**\n     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).\n     */\n    get maxVelocityIterations(): number {\n        return this.raw.maxVelocityIterations;\n    }\n\n    /**\n     * Maximum number of friction iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxVelocityFrictionIterations(): number {\n        return this.raw.maxVelocityFrictionIterations;\n    }\n\n    /**\n     * Maximum number of stabilization iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxStabilizationIterations(): number {\n        return this.raw.maxStabilizationIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set erp(value: number) {\n        this.raw.erp = value;\n    }\n\n    set allowedLinearError(value: number) {\n        this.raw.allowedLinearError = value;\n    }\n\n    set predictionDistance(value: number) {\n        this.raw.predictionDistance = value;\n    }\n\n    set maxVelocityIterations(value: number) {\n        this.raw.maxVelocityIterations = value;\n    }\n\n    set maxVelocityFrictionIterations(value: number) {\n        this.raw.maxVelocityFrictionIterations = value;\n    }\n\n    set maxStabilizationIterations(value: number) {\n        this.raw.maxStabilizationIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n}\n", "import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {\n    RawGenericJoint,\n    RawImpulseJointSet,\n    RawRigidBodySet,\n    RawJointAxis,\n} from \"../raw\";\nimport {RigidBody, RigidBodyHandle} from \"./rigid_body\";\nimport {RigidBodySet} from \"./rigid_body_set\";\n// #if DIM3\nimport {Quaternion} from \"../math\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ImpulseJointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n */\nexport enum JointType {\n    Revolute,\n    Fixed,\n    Prismatic,\n    // #if DIM3\n    Spherical,\n    // #endif\n}\n\nexport enum MotorModel {\n    AccelerationBased,\n    ForceBased,\n}\n\nexport class ImpulseJoint {\n    protected rawSet: RawImpulseJointSet; // The ImpulseJoint won't need to free this.\n    protected bodySet: RigidBodySet; // The ImpulseJoint won’t need to free this.\n    handle: ImpulseJointHandle;\n\n    constructor(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ): ImpulseJoint {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodySet: RigidBodySet) {\n        this.bodySet = bodySet;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    public body1(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    public body2(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle);\n    }\n\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    public frameX1(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n\n    // #endif\n\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    public frameX2(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n\n    // #endif\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public setAnchor1(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public setAnchor2(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joint’s free coordinate.\n     * @param max - The maximum bound of this joint’s free coordinate.\n     */\n    public setLimits(min: number, max: number) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(\n            this.handle,\n            this.rawAxis(),\n            model,\n        );\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureMotorVelocity(\n            this.handle,\n            this.rawAxis(),\n            targetVel,\n            factor,\n        );\n    }\n\n    public configureMotorPosition(\n        targetPos: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotorPosition(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            stiffness,\n            damping,\n        );\n    }\n\n    public configureMotor(\n        targetPos: number,\n        targetVel: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotor(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            targetVel,\n            stiffness,\n            damping,\n        );\n    }\n}\n\nexport class FixedImpulseJoint extends ImpulseJoint {}\n\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class SphericalImpulseJoint extends ImpulseJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n\nexport class JointData {\n    anchor1: Vector;\n    anchor2: Vector;\n    axis: Vector;\n    frame1: Rotation;\n    frame2: Rotation;\n    jointType: JointType;\n    limitsEnabled: boolean;\n    limits: Array<number>;\n\n    private constructor() {}\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(\n        anchor1: Vector,\n        frame1: Rotation,\n        anchor2: Vector,\n        frame2: Rotation,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static spherical(anchor1: Vector, anchor2: Vector): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static revolute(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n\n    // #endif\n\n    public intoRaw(): RawGenericJoint {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n\n                // #if DIM3\n                result = RawGenericJoint.prismatic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                // #endif\n\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}\n", "import {RawImpulseJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    RevoluteImpulseJoint,\n    FixedImpulseJoint,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    JointData,\n    JointType,\n    PrismaticImpulseJoint,\n    // #if DIM3\n    SphericalImpulseJoint,\n    // #endif\n} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {RigidBodyHandle} from \"./rigid_body\";\nimport {Collider, ColliderHandle} from \"../geometry\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    raw: RawImpulseJointSet;\n    private map: Coarena<ImpulseJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawImpulseJointSet) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena<ImpulseJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: ImpulseJointHandle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: ImpulseJointHandle, wakeUp: boolean) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: ImpulseJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: ImpulseJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: ImpulseJointHandle): ImpulseJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: ImpulseJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): ImpulseJoint[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawImpulseJointSet, RawJointAxis, RawMultibodyJointSet} from \"../raw\";\nimport {\n    FixedImpulseJoint,\n    ImpulseJointHandle,\n    JointType,\n    MotorModel,\n    PrismaticImpulseJoint,\n    RevoluteImpulseJoint,\n} from \"./impulse_joint\";\n\n// #if DIM3\nimport {Quaternion} from \"../math\";\nimport {SphericalImpulseJoint} from \"./impulse_joint\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type MultibodyJointHandle = number;\n\nexport class MultibodyJoint {\n    protected rawSet: RawMultibodyJointSet; // The MultibodyJoint won't need to free this.\n    handle: MultibodyJointHandle;\n\n    constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawMultibodyJointSet,\n        handle: MultibodyJointHandle,\n    ): MultibodyJoint {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case JointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case JointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitMultibodyJoint extends MultibodyJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    // /**\n    //  * Are the limits enabled for this joint?\n    //  */\n    // public limitsEnabled(): boolean {\n    //     return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The min limit of this joint.\n    //  */\n    // public limitsMin(): number {\n    //     return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The max limit of this joint.\n    //  */\n    // public limitsMax(): number {\n    //     return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    // }\n    //\n    // public configureMotorModel(model: MotorModel) {\n    //     this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    // }\n    //\n    // public configureMotorVelocity(targetVel: number, factor: number) {\n    //     this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    // }\n    //\n    // public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    // }\n    //\n    // public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    // }\n}\n\nexport class FixedMultibodyJoint extends MultibodyJoint {}\n\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n", "import {RawMultibodyJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    MultibodyJoint,\n    MultibodyJointHandle,\n    RevoluteMultibodyJoint,\n    FixedMultibodyJoint,\n    PrismaticMultibodyJoint,\n    // #if DIM3\n    SphericalMultibodyJoint,\n    // #endif\n} from \"./multibody_joint\";\nimport {ImpulseJointHandle, JointData, JointType} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {ColliderHandle} from \"../geometry\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    raw: RawMultibodyJointSet;\n    private map: Coarena<MultibodyJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawMultibodyJointSet) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena<MultibodyJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: MultibodyJointHandle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: MultibodyJointHandle, wake_up: boolean) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: MultibodyJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: MultibodyJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: MultibodyJointHandle): MultibodyJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: MultibodyJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: MultibodyJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): MultibodyJoint[] {\n        return this.map.getAll();\n    }\n}\n", "/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}\n", "import {RawCCDSolver} from \"../raw\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}\n", "import {RawIslandManager} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n", "import {RawBroadPhase} from \"../raw\";\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n}\n", "import {RawNarrowPhase, RawContactManifold} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.contacts_with(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.intersections_with(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    public intersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n    ): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n\n    // #if DIM3\n    public contactTangentImpulseX(i: number): number {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n\n    public contactTangentImpulseY(i: number): number {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {RawShapeContact} from \"../raw\";\n\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    /**\n     * Distance between the two contact points.\n     * If this is negative, this contact represents a penetration.\n     */\n    distance: number;\n\n    /**\n     * Position of the contact on the first shape.\n     */\n    point1: Vector;\n\n    /**\n     * Position of the contact on the second shape.\n     */\n    point2: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the first shape.\n     */\n    normal1: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the second shape.\n     * If these contact data are expressed in world-space, this normal is equal to -normal1.\n     */\n    normal2: Vector;\n\n    constructor(\n        dist: number,\n        point1: Vector,\n        point2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeContact): ShapeContact {\n        if (!raw) return null;\n\n        const result = new ShapeContact(\n            raw.distance(),\n            VectorOps.fromRaw(raw.point1()),\n            VectorOps.fromRaw(raw.point2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "\n// #if DIM3\nexport enum FeatureType {\n    Vertex,\n    Edge,\n    Face,\n    Unknown,\n}\n// #endif\n", "import {Collider, ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawPointColliderProjection, RawPointProjection} from \"../raw\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    constructor(point: Vector, isInside: boolean) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointProjection): PointProjection {\n        if (!raw) return null;\n\n        const result = new PointProjection(\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        point: Vector,\n        isInside: boolean,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawPointColliderProjection,\n    ): PointColliderProjection {\n        if (!raw) return null;\n\n        const result = new PointColliderProjection(\n            colliderSet.get(raw.colliderHandle()),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps} from \"../math\";\nimport {\n    RawRayColliderIntersection,\n    RawRayColliderToi,\n    RawRayIntersection,\n} from \"../raw\";\nimport {Collider} from \"./collider\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector;\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector;\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        toi: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(raw: RawRayIntersection): RayIntersection {\n        if (!raw) return null;\n\n        const result = new RayIntersection(\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        toi: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderIntersection,\n    ): RayColliderIntersection {\n        if (!raw) return null;\n\n        const result = new RayColliderIntersection(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n\n    constructor(collider: Collider, toi: number) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderToi,\n    ): RayColliderToi {\n        if (!raw) return null;\n\n        const result = new RayColliderToi(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Collider} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeTOI, RawShapeColliderTOI} from \"../raw\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    /**\n     * The time of impact of the two shapes.\n     */\n    toi: number;\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector;\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector;\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector;\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector;\n\n    constructor(\n        toi: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeTOI,\n    ): ShapeTOI {\n        if (!raw) return null;\n\n        const result = new ShapeTOI(\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n\n    constructor(\n        collider: Collider,\n        toi: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeColliderTOI,\n    ): ShapeColliderTOI {\n        if (!raw) return null;\n\n        const result = new ShapeColliderTOI(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n", "import {Vector, VectorOps, Rotation, RotationOps} from \"../math\";\nimport {RawColliderSet, RawShape} from \"../raw\";\nimport {ShapeContact} from \"./contact\";\nimport {PointProjection} from \"./point\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {ShapeTOI} from \"./toi\";\nimport {ColliderHandle} from \"./collider\";\n\nexport abstract class Shape {\n    public abstract intoRaw(): RawShape;\n\n    /**\n     * The concrete type of this shape.\n     */\n    public abstract get type(): ShapeType;\n\n    /**\n     * instant mode without cache\n     */\n    public static fromRaw(\n        rawSet: RawColliderSet,\n        handle: ColliderHandle,\n    ): Shape {\n        const rawType = rawSet.coShapeType(handle);\n\n        let extents: Vector;\n        let borderRadius: number;\n        let vs: Float32Array;\n        let indices: Uint32Array;\n        let halfHeight: number;\n        let radius: number;\n        let normal: Vector;\n\n        switch (rawType) {\n            case ShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case ShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n\n            case ShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundCuboid(\n                    extents.x,\n                    extents.y,\n                    extents.z,\n                    borderRadius,\n                );\n            // #endif\n\n            case ShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case ShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Segment(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                );\n            // #endif\n\n            case ShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case ShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Triangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                );\n            // #endif\n\n            case ShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundTriangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                    borderRadius,\n                );\n            // #endif\n\n            case ShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n\n            case ShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n\n            case ShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n\n\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                return new Heightfield(nrows, ncols, heights, scale);\n            // #endif\n\n\n            // #if DIM3\n            case ShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case ShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case ShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case ShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case ShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case ShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    public castShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shapeVel1: Vector,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        shapeVel2: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeTOI | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeTOI.fromRaw(\n            null,\n            rawShape1.castShape(\n                rawPos1,\n                rawRot1,\n                rawVel1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                rawVel2,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don’t.\n     */\n    public intersectsShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = rawShape1.intersectsShape(\n            rawPos1,\n            rawRot1,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            rawShape1.contactShape(\n                rawPos1,\n                rawRot1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    containsPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    projectPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n        solid: boolean,\n    ): PointProjection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = PointProjection.fromRaw(\n            rawShape.projectPoint(rawPos, rawRot, rawPoint, solid),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    intersectsRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.intersectsRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): number {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.castRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n            solid,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRayAndGetNormal(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = RayIntersection.fromRaw(\n            rawShape.castRayAndGetNormal(\n                rawPos,\n                rawRot,\n                rawRayOrig,\n                rawRayDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n}\n\n\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolyhedron = 9,\n    Cylinder = 10,\n    Cone = 11,\n    RoundCuboid = 12,\n    RoundTriangle = 13,\n    RoundCylinder = 14,\n    RoundCone = 15,\n    RoundConvexPolyhedron = 16,\n    HalfSpace = 17,\n}\n\n// #endif\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    readonly type = ShapeType.Ball;\n\n    /**\n     * The balls radius.\n     */\n    radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        super();\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\nexport class HalfSpace extends Shape {\n    readonly type = ShapeType.HalfSpace;\n\n    /**\n     * The outward normal of the half-space.\n     */\n    normal: Vector;\n\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal: Vector) {\n        super();\n        this.normal = normal;\n    }\n\n    public intoRaw(): RawShape {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    readonly type = ShapeType.Cuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx: number, hy: number, hz: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.cuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    readonly type = ShapeType.RoundCuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, hz: number, borderRadius: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.roundCuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n            this.borderRadius,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    readonly type = ShapeType.Capsule;\n\n    /**\n     * The radius of the capsule's basis.\n     */\n    radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    readonly type = ShapeType.Segment;\n\n    /**\n     * The first point of the segment.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    readonly type = ShapeType.Triangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    readonly type = ShapeType.RoundTriangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    readonly type = ShapeType.Polyline;\n\n    /**\n     * The vertices of the polyline.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices ?? new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    readonly type = ShapeType.TriMesh;\n\n    /**\n     * The vertices of the triangle mesh.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n\n\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    readonly type = ShapeType.ConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array | null;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array | null) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    readonly type = ShapeType.RoundConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array;\n\n    /**\n     * The radius of the convex polyhedron's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array | null | undefined,\n        borderRadius: number,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(\n                this.vertices,\n                this.indices,\n                this.borderRadius,\n            );\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    readonly type = ShapeType.HeightField;\n\n    /**\n     * The number of rows in the heights matrix.\n     */\n    nrows: number;\n\n    /**\n     * The number of columns in the heights matrix.\n     */\n    ncols: number;\n\n    /**\n     * The heights of the heightfield along its local `y` axis,\n     * provided as a matrix stored in column-major order.\n     */\n    heights: Float32Array;\n\n    /**\n     * The dimensions of the heightfield's local `x,z` plane.\n     */\n    scale: Vector;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows − The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n    ) {\n        super();\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(\n            this.nrows,\n            this.ncols,\n            this.heights,\n            rawScale,\n        );\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    readonly type = ShapeType.Cylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    readonly type = ShapeType.RoundCylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCylinder(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    readonly type = ShapeType.Cone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    readonly type = ShapeType.RoundCone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCone(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n// #endif\n", "import {RawColliderSet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {\n    CoefficientCombineRule,\n    RigidBody,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {\n    Shape,\n    Cuboid,\n    Ball,\n    ShapeType,\n    Capsule,\n    TriMesh,\n    Polyline,\n    Heightfield,\n    Segment,\n    Triangle,\n    RoundTriangle,\n    RoundCuboid,\n    HalfSpace,\n    // #if DIM3\n    Cylinder,\n    RoundCylinder,\n    Cone,\n    RoundCone,\n    ConvexPolyhedron,\n    RoundConvexPolyhedron,\n    // #endif\n} from \"./shape\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {PointProjection} from \"./point\";\nimport {ShapeColliderTOI, ShapeTOI} from \"./toi\";\nimport {ShapeContact} from \"./contact\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport enum ActiveCollisionTypes {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    DYNAMIC_FIXED = 0b0000_0000_0000_0010,\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    KINEMATIC_FIXED = 0b0010_0010_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    FIXED_FIXED = 0b0000_0000_0010_0000,\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_FIXED,\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ALL = DYNAMIC_KINEMATIC |\n        DYNAMIC_DYNAMIC |\n        DYNAMIC_FIXED |\n        KINEMATIC_KINEMATIC |\n        KINEMATIC_FIXED |\n        KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private colliderSet: ColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n    private _shape: Shape;\n    private _parent: RigidBody | null;\n\n    constructor(\n        colliderSet: ColliderSet,\n        handle: ColliderHandle,\n        parent: RigidBody | null,\n        shape?: Shape,\n    ) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        if (this.handle != null) {\n            this._parent = bodies.get(\n                this.colliderSet.raw.coParent(this.handle),\n            );\n        }\n    }\n\n    private ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n\n    /**\n     * The shape of this collider.\n     */\n    public get shape(): Shape {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    public isValid(): boolean {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslation(this.handle),\n        );\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotation(this.handle),\n        );\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    public setSensor(isSensor: boolean) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider’s new shape.\n     */\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body won’t be disabled automatically by this).\n     */\n    public setEnabled(enabled: boolean) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this collider enabled?\n     */\n    public isEnabled(): boolean {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    public setContactForceEventThreshold(threshold: number) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(\n            this.handle,\n            threshold,\n        );\n    }\n\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    public contactForceEventThreshold(): number {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(\n            this.handle,\n            activeCollisionTypes,\n        );\n    }\n\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    public setDensity(density: number) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    public setMass(mass: number) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.colliderSet.raw.coSetMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(\n            this.handle,\n            tra.x,\n            tra.y,\n            tra.z,\n        );\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotation(rot: Rotation) {\n        this.colliderSet.raw.coSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotationWrtParent(rot: Rotation) {\n        this.colliderSet.raw.coSetRotationWrtParent(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public shapeType(): ShapeType {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coHalfExtents(this.handle),\n        );\n    }\n\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    public setHalfExtents(newHalfExtents: Vector) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public radius(): number {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    public setRadius(newRadius: number): void {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public roundRadius(): number {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    public setRoundRadius(newBorderRadius: number) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfHeight(): number {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    public setHalfHeight(newHalfheight: number) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public vertices(): Float32Array {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public indices(): Uint32Array | undefined {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNRows(): number {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNCols(): number {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    public parent(): RigidBody | null {\n        return this._parent;\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n\n    /**\n     * The restitution coefficient of this collider.\n     */\n    public restitution(): number {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n\n    /**\n     * The mass of this collider.\n     */\n    public mass(): number {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n\n    /**\n     * The volume of this collider.\n     */\n    public volume(): number {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    public containsPoint(point: Vector): boolean {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(\n            this.handle,\n            rawPoint,\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    public projectPoint(point: Vector, solid: boolean): PointProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(\n            this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    public intersectsRay(ray: Ray, maxToi: number): boolean {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     */\n    public castShape(\n        collider1Vel: Vector,\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        shape2Vel: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeTOI | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeTOI.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastShape(\n                this.handle,\n                rawCollider1Vel,\n                rawShape2,\n                rawShape2Pos,\n                rawShape2Rot,\n                rawShape2Vel,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     */\n    public castCollider(\n        collider1Vel: Vector,\n        collider2: Collider,\n        collider2Vel: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeColliderTOI | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n\n        let result = ShapeColliderTOI.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastCollider(\n                this.handle,\n                rawCollider1Vel,\n                collider2.handle,\n                rawCollider2Vel,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n\n        return result;\n    }\n\n    public intersectsShape(\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = this.colliderSet.raw.coIntersectsShape(\n            this.handle,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactShape(\n                this.handle,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(\n        collider2: Collider,\n        prediction: number,\n    ): ShapeContact | null {\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactCollider(\n                this.handle,\n                collider2.handle,\n                prediction,\n            ),\n        );\n\n        return result;\n    }\n\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    public castRay(ray: Ray, maxToi: number, solid: boolean): number {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(\n            this.colliderSet.raw.coCastRayAndGetNormal(\n                this.handle,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n}\n\nexport enum MassPropsMode {\n    Density,\n    Mass,\n    MassProps,\n}\n\nexport class ColliderDesc {\n    enabled: boolean;\n    shape: Shape;\n    massPropsMode: MassPropsMode;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM3\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n    contactForceEventThreshold: number;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = 0;\n        this.activeHooks = 0;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(\n        a: Vector,\n        b: Vector,\n        c: Vector,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(\n        vertices: Float32Array,\n        indices: Uint32Array,\n    ): ColliderDesc {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    public static cuboid(hx: number, hy: number, hz: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(\n        hx: number,\n        hy: number,\n        hz: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows − The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n    ): ColliderDesc {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    public static cylinder(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    public static roundCylinder(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    public static cone(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    public static roundCone(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexMesh(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    public static roundConvexHull(\n        points: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexMesh(\n        vertices: Float32Array,\n        indices: Uint32Array | null,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(\n            vertices,\n            indices,\n            borderRadius,\n        );\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number, z: number): ColliderDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(sensor: boolean): ColliderDesc {\n        this.isSensor = sensor;\n        return this;\n    }\n\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled − If set to `false` the collider will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): ColliderDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the collider’s shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the collider’s shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    public setMass(mass: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass − The mass of the collider to create.\n     * @param centerOfMass − The center-of-mass of the collider to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame − The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): ColliderDesc {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        return this;\n    }\n    // #endif\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    public setRestitutionCombineRule(\n        rule: CoefficientCombineRule,\n    ): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(\n        activeCollisionTypes: ActiveCollisionTypes,\n    ): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    public setContactForceEventThreshold(threshold: number): ColliderDesc {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n", "import {RawColliderSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RotationOps, VectorOps} from \"../math\";\nimport {Collider, ColliderDesc, ColliderHandle} from \"./collider\";\nimport {ImpulseJointHandle, IslandManager, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n    private map: Coarena<Collider>;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena<Collider>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle: ColliderHandle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n\n    /** @internal */\n    public castClosure<Res>(\n        f?: (collider: Collider) => Res,\n    ): (handle: ColliderHandle) => Res | undefined {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            } else {\n                return undefined;\n            }\n        };\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((collider) =>\n            collider.finalizeDeserialization(bodies),\n        );\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(\n        bodies: RigidBodySet,\n        desc: ColliderDesc,\n        parentHandle: RigidBodyHandle,\n    ): Collider {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\n                \"Cannot create a collider with a parent rigid-body handle that is not a number.\",\n            );\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createCollider(\n            desc.enabled,\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.massPropsMode,\n            desc.mass,\n            rawCom,\n            // #if DIM3\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            desc.contactForceEventThreshold,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(\n        handle: ColliderHandle,\n        islands: IslandManager,\n        bodies: RigidBodySet,\n        wakeUp: boolean,\n    ) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (collider: Collider) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    public getAll(): Collider[] {\n        return this.map.getAll();\n    }\n}\n", "import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodyHandle,\n    RigidBodySet,\n    CCDSolver,\n    IslandManager,\n} from \"../dynamics\";\nimport {\n    BroadPhase,\n    ColliderHandle,\n    ColliderSet,\n    NarrowPhase,\n} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n            );\n        }\n\n        rawG.free();\n    }\n}\n", "import {RawQueryPipeline, RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi,\n    Shape,\n    ShapeColliderTOI,\n} from \"../geometry\";\nimport {IslandManager, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport enum QueryFilterFlags {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    EXCLUDE_FIXED = 0b0000_0001,\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    EXCLUDE_KINEMATIC = 0b0000_0010,\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    EXCLUDE_DYNAMIC = 0b0000_0100,\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    EXCLUDE_SENSORS = 0b0000_1000,\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    EXCLUDE_SOLIDS = 0b0001_0000,\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    ONLY_DYNAMIC = QueryFilterFlags.EXCLUDE_FIXED |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    ONLY_KINEMATIC = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_FIXED,\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    ONLY_FIXED = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n}\n\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    raw: RawQueryPipeline;\n\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawQueryPipeline) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    public update(bodies: RigidBodySet, colliders: ColliderSet) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderToi | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(\n            colliders,\n            this.raw.castRay(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(\n            colliders,\n            this.raw.castRayAndGetNormal(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(\n                RayColliderIntersection.fromRaw(colliders, rawInter),\n            );\n        };\n\n        this.raw.intersectionsWithRay(\n            bodies.raw,\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            rawCallback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPoint(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPointAndGetFeature(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            bodies.raw,\n            colliders.raw,\n            rawPoint,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ShapeColliderTOI | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ShapeColliderTOI.fromRaw(\n            colliders,\n            this.raw.castShape(\n                bodies.raw,\n                colliders.raw,\n                rawPos,\n                rawRot,\n                rawVel,\n                rawShape,\n                maxToi,\n                stopAtPenetration,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(\n            rawCenter,\n            rawHalfExtents,\n            callback,\n        );\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n", "import {RawSerializationPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n", "import {RawDebugRenderPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    /**\n     * The lines to render. This is a flat array containing all the lines\n     * to render. Each line is described as two consecutive point. Each\n     * point is described as two (in 2D) or three (in 3D) consecutive\n     * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`\n     * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.\n     */\n    public vertices: Float32Array;\n    /**\n     * The color buffer. There is one color per vertex, and each color\n     * has four consecutive components (in RGBA format).\n     */\n    public colors: Float32Array;\n\n    constructor(vertices: Float32Array, colors: Float32Array) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    raw: RawDebugRenderPipeline;\n    public vertices: Float32Array;\n    public colors: Float32Array;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n\n    constructor(raw?: RawDebugRenderPipeline) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n\n    public render(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulse_joints: ImpulseJointSet,\n        multibody_joints: MultibodyJointSet,\n        narrow_phase: NarrowPhase,\n    ) {\n        this.raw.render(\n            bodies.raw,\n            colliders.raw,\n            impulse_joints.raw,\n            multibody_joints.raw,\n            narrow_phase.raw,\n        );\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n", "import {RawKinematicCharacterController, RawCharacterCollision} from \"../raw\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n    /** The collider involved in the collision. Null if the collider no longer exists in the physics world. */\n    public collider: Collider | null;\n    /** The translation applied to the character before this collision took place. */\n    public translationApplied: Vector;\n    /** The translation the character would move after this collision if there is no other obstacles. */\n    public translationRemaining: Vector;\n    /** The time-of-impact between the character and the obstacles. */\n    public toi: number;\n    /** The world-space contact point on the collider when the collision happens. */\n    public witness1: Vector;\n    /** The local-space contact point on the character when the collision happens. */\n    public witness2: Vector;\n    /** The world-space outward contact normal on the collider when the collision happens. */\n    public normal1: Vector;\n    /** The local-space outward contact normal on the character when the collision happens. */\n    public normal2: Vector;\n}\n\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    private raw: RawKinematicCharacterController;\n    private rawCharacterCollision: RawCharacterCollision;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _applyImpulsesToDynamicBodies: boolean;\n    private _characterMass: number | null;\n\n    constructor(\n        offset: number,\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    public up(): Vector {\n        return this.raw.up();\n    }\n\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    public setUp(vector: Vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n\n    public applyImpulsesToDynamicBodies(): boolean {\n        return this._applyImpulsesToDynamicBodies;\n    }\n\n    public setApplyImpulsesToDynamicBodies(enabled: boolean) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    public characterMass(): number | null {\n        return this._characterMass;\n    }\n\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isn’t attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    public setCharacterMass(mass: number | null) {\n        this._characterMass = mass;\n    }\n\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public offset(): number {\n        return this.raw.offset();\n    }\n\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public setOffset(value: number) {\n        this.raw.setOffset(value);\n    }\n\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    public slideEnabled(): boolean {\n        return this.raw.slideEnabled();\n    }\n\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    public setSlideEnabled(enabled: boolean) {\n        this.raw.setSlideEnabled(enabled);\n    }\n\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    public autostepMaxHeight(): number | null {\n        return this.raw.autostepMaxHeight();\n    }\n\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    public autostepMinWidth(): number | null {\n        return this.raw.autostepMinWidth();\n    }\n\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    public autostepIncludesDynamicBodies(): boolean | null {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    public autostepEnabled(): boolean {\n        return this.raw.autostepEnabled();\n    }\n\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    public enableAutostep(\n        maxHeight: number,\n        minWidth: number,\n        includeDynamicBodies: boolean,\n    ) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    public disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n\n    /**\n     * The maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public maxSlopeClimbAngle(): number {\n        return this.raw.maxSlopeClimbAngle();\n    }\n\n    /**\n     * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public setMaxSlopeClimbAngle(angle: number) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n\n    /**\n     * The minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public minSlopeSlideAngle(): number {\n        return this.raw.minSlopeSlideAngle();\n    }\n\n    /**\n     * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public setMinSlopeSlideAngle(angle: number) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    public snapToGroundDistance(): number | null {\n        return this.raw.snapToGroundDistance();\n    }\n\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    public enableSnapToGround(distance: number) {\n        this.raw.enableSnapToGround(distance);\n    }\n\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    public disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    public snapToGroundEnabled(): boolean {\n        return this.raw.snapToGroundEnabled();\n    }\n\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslation - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    public computeColliderMovement(\n        collider: Collider,\n        desiredTranslation: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        let rawTranslation = VectorOps.intoRaw(desiredTranslation);\n        this.raw.computeColliderMovement(\n            this.params.dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            collider.handle,\n            rawTranslation,\n            this._applyImpulsesToDynamicBodies,\n            this._characterMass,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n        rawTranslation.free();\n    }\n\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedMovement(): Vector {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedGrounded(): boolean {\n        return this.raw.computedGrounded();\n    }\n\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    public numComputedCollisions(): number {\n        return this.raw.numComputedCollisions();\n    }\n\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    public computedCollision(\n        i: number,\n        out?: CharacterCollision,\n    ): CharacterCollision | null {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        } else {\n            let c = this.rawCharacterCollision;\n            out = out ?? new CharacterCollision();\n            out.translationApplied = VectorOps.fromRaw(c.translationApplied());\n            out.translationRemaining = VectorOps.fromRaw(\n                c.translationRemaining(),\n            );\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n", "import {\n    RawBroadPhase,\n    RawCCDSolver,\n    RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters,\n    RawIslandManager,\n    RawImpulseJointSet,\n    RawMultibodyJointSet,\n    RawNarrowPhase,\n    RawPhysicsPipeline,\n    RawQueryPipeline,\n    RawRigidBodySet,\n    RawSerializationPipeline,\n    RawDebugRenderPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider,\n    ColliderDesc,\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi,\n    Shape,\n    ShapeColliderTOI,\n    TempContactManifold,\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    MultibodyJoint,\n    MultibodyJointHandle,\n    JointData,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryFilterFlags, QueryPipeline} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\nimport {DebugRenderBuffers, DebugRenderPipeline} from \"./debug_render_pipeline\";\nimport {KinematicCharacterController} from \"../control\";\nimport {Coarena} from \"../coarena\";\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector;\n    integrationParameters: IntegrationParameters;\n    islands: IslandManager;\n    broadPhase: BroadPhase;\n    narrowPhase: NarrowPhase;\n    bodies: RigidBodySet;\n    colliders: ColliderSet;\n    impulseJoints: ImpulseJointSet;\n    multibodyJoints: MultibodyJointSet;\n    ccdSolver: CCDSolver;\n    queryPipeline: QueryPipeline;\n    physicsPipeline: PhysicsPipeline;\n    serializationPipeline: SerializationPipeline;\n    debugRenderPipeline: DebugRenderPipeline;\n    characterControllers: Set<KinematicCharacterController>;\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawImpulseJoints?: RawImpulseJointSet,\n        rawMultibodyJoints?: RawMultibodyJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawQueryPipeline?: RawQueryPipeline,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline,\n        rawDebugRenderPipeline?: RawDebugRenderPipeline,\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(\n            rawIntegrationParameters,\n        );\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(\n            rawSerializationPipeline,\n        );\n        this.debugRenderPipeline = new DebugRenderPipeline(\n            rawDebugRenderPipeline,\n        );\n        this.characterControllers = new Set<KinematicCharacterController>();\n\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw) return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeImpulseJoints(),\n            raw.takeMultibodyJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    public debugRender(): DebugRenderBuffers {\n        this.debugRenderPipeline.render(\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.narrowPhase,\n        );\n        return new DebugRenderBuffers(\n            this.debugRenderPipeline.vertices,\n            this.debugRenderPipeline.colors,\n        );\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    public propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(\n            this.colliders.raw,\n        );\n    }\n\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    public updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based force constraint solver can make.\n     */\n    get maxVelocityIterations(): number {\n        return this.integrationParameters.maxVelocityIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations (default: 4).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityIterations(niter: number) {\n        this.integrationParameters.maxVelocityIterations = niter;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based friction constraint solver can make.\n     */\n    get maxVelocityFrictionIterations(): number {\n        return this.integrationParameters.maxVelocityFrictionIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations for friction (default: 8).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityFrictionIterations(niter: number) {\n        this.integrationParameters.maxVelocityFrictionIterations = niter;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based constraint solver can make to attempt to remove\n     * the energy introduced by constraint stabilization.\n     */\n    get maxStabilizationIterations(): number {\n        return this.integrationParameters.maxStabilizationIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations for stabilization (default: 1).\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxStabilizationIterations(niter: number) {\n        this.integrationParameters.maxStabilizationIterations = niter;\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigd-body descriptior.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the character’s chape and its environment.\n     */\n    public createCharacterController(\n        offset: number,\n    ): KinematicCharacterController {\n        let controller = new KinematicCharacterController(\n            offset,\n            this.integrationParameters,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.characterControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    public removeCharacterController(controller: KinematicCharacterController) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parent?: RigidBody): Collider {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createImpulseJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        return this.impulseJoints.createJoint(\n            this.bodies,\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createMultibodyJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        return this.multibodyJoints.createJoint(\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    public getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint {\n        return this.impulseJoints.get(handle);\n    }\n\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    public getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint {\n        return this.multibodyJoints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        if (this.bodies) {\n            this.bodies.remove(\n                body.handle,\n                this.islands,\n                this.colliders,\n                this.impulseJoints,\n                this.multibodyJoints,\n            );\n        }\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        if (this.colliders) {\n            this.colliders.remove(\n                collider.handle,\n                this.islands,\n                this.bodies,\n                wakeUp,\n            );\n        }\n    }\n\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderToi | null {\n        return this.queryPipeline.castRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderIntersection | null {\n        return this.queryPipeline.castRayAndGetNormal(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): Collider | null {\n        let handle = this.queryPipeline.intersectionWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPointAndGetFeature(\n            this.bodies,\n            this.colliders,\n            point,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        callback: (handle: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): ShapeColliderTOI | null {\n        return this.queryPipeline.castShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shapeVel,\n            shape,\n            maxToi,\n            stopAtPenetration,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (collider: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: Collider) => boolean,\n    ) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(\n            aabbCenter,\n            aabbHalfExtents,\n            this.colliders.castClosure(callback),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(collider1: Collider, f: (collider2: Collider) => void) {\n        this.narrowPhase.contactsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.intersectionsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: Collider,\n        collider2: Collider,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: Collider, collider2: Collider): boolean {\n        return this.narrowPhase.intersectionPair(\n            collider1.handle,\n            collider2.handle,\n        );\n    }\n}\n", "import {RawContactForceEvent, RawEventQueue} from \"../raw\";\nimport {RigidBodyHandle} from \"../dynamics\";\nimport {Collider, ColliderHandle} from \"../geometry\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport enum ActiveEvents {\n    /**\n     * Enable collision events.\n     */\n    COLLISION_EVENTS = 0b0001,\n    /**\n     * Enable contact force events.\n     */\n    CONTACT_FORCE_EVENTS = 0b0010,\n}\n\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    raw: RawContactForceEvent;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The first collider involved in the contact.\n     */\n    public collider1(): ColliderHandle {\n        return this.raw.collider1();\n    }\n\n    /**\n     * The second collider involved in the contact.\n     */\n    public collider2(): ColliderHandle {\n        return this.raw.collider2();\n    }\n\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    public totalForce(): Vector {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    public totalForceMagnitude(): number {\n        return this.raw.total_force_magnitude();\n    }\n\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    public maxForceDirection(): Vector {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    public maxForceMagnitude(): number {\n        return this.raw.max_force_magnitude();\n    }\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue;\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    public drainCollisionEvents(\n        f: (\n            handle1: ColliderHandle,\n            handle2: ColliderHandle,\n            started: boolean,\n        ) => void,\n    ) {\n        this.raw.drainCollisionEvents(f);\n    }\n\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    public drainContactForceEvents(f: (event: TempContactForceEvent) => void) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw: RawContactForceEvent) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}\n", "import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1 − Handle of the first collider involved in the potential contact.\n     * @param collider2 − Handle of the second collider involved in the potential contact.\n     * @param body1 − Handle of the first body involved in the potential contact.\n     * @param body2 − Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): SolverFlags | null;\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1 − Handle of the first collider involved in the potential contact.\n     * @param collider2 − Handle of the second collider involved in the potential contact.\n     * @param body1 − Handle of the first body involved in the potential contact.\n     * @param body2 − Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): boolean;\n}\n", "import * as RAPIER from \"./exports\";\nexport * from \"./exports\";\nexport default RAPIER;\n"],
  "mappings": "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",
  "names": ["version", "wasm", "version", "RigidBodyType", "handle", "JointType", "MotorModel", "CoefficientCombineRule", "FeatureType", "ShapeType", "ActiveCollisionTypes", "MassPropsMode", "QueryFilterFlags", "ActiveEvents", "ActiveHooks", "SolverFlags", "version"]
}
